You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

```
Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

```
Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

# 로직

#### 내가 생각한 로직(틀림 주의..!)

- 문제를 보고 이해는 가는데 또 어떻게 풀까? 고민에 빠졌다. 원시인인 나는 역시나 일단 모든 경우의 수를 구해보며 발견하고자 했다.
- 와우,, n이 총 8일 때의 값까지 구해보며 패턴을 발견했다!!!!! 하지만 이걸 또 코드로 나타내기가 첩첩산중이다 ㅎㅎ.. 오늘 할당된 알고리즘 문제 풀이 시간이 초과되었기 때문에 오늘 하루 짬내서 더 고민하고 내일 풀어볼 예정이다.
  ![](https://images.velog.io/images/sgr2134/post/aa4f1b1c-8d90-4745-9694-17ea171ab3dc/image.png)
- 예: 인자로 4가 들어올 경우
  ![](https://images.velog.io/images/sgr2134/post/53e33f07-ceaf-4ecc-ad13-84eca54d1b9c/image.png)

#### 😲 멋진 로직...(와우...)

- 어떻게 문제를 푸는지 고민하다가 해답을 봤는데 너무 간단하고도 깔끔했다.
- 수학적인 개념이 없이는 한번에 생각해내기란 어려울 것 같지만,, 문제를 이해하기 위해 필요했던 몇가지 사실에 대해 간단히 설명하고자 한다.
- 나의 로직이 왠지 부끄러워지는데...ㅎㅎ
- 위키백과와 문제에 대해 알기 [쉽게 설명해준 블로그](https://blog.naver.com/ndb796/221233570962) 덕분에 이해를 했다..

#### Dynamic Programming

- 이번 문제의 핵심은 Dynamic Programming을 활용한 문제로 풀이 방법은 간단하지만 컴퓨터적인 사고가 없다면 꽤나 풀어내기가 힘들수도 있는 문제였다.
- 일단 사전적인 정의는 복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방법을 말하며 알고리즘을 일반적인 방법에 비해 더 적은 시간 내에 풀고자 할 때 사용한다고 한다.
- 한마디로 하나의 문제는 단 한번만 풀도록 하는 알고리즘이라고 할 수 있다.

#### 피보나치 수열

- 이런 Dynamic Programming의 대표적인 예가 피보나치 수열인 것 같다. 피보나치 수열은 첫째 항과 둘째 항이 1이며 모든 항은 바로 앞 두 항의 합인 수열을 말한다. [피보나치수열](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98)
- 피보나치 수열은 분할 정복 기법을 통해 푸는 것 같은데, 이 기법에는 동일한 문제를 다시 풀게한다는 단점이 존재한다.(정렬과 같은 몇몇 요소를 제외하고..!) 이때 단순하게 분할 정복을 시도한다면 심각하게 비효율적이게 되어버린다.
- 이유는 이미 해결한 문제를 풀고자 그 이전의 값을 참조하고자 할때 반복해서 이전 계산값들을 구하는 과정이 이루어지기 때문으로 보인다. (마치 리액트에서 렌더링이 될 때마다 값들을 초기화 하는 것 마냥... 클로저 때문에 계산된 값들이 마치 죽지 못하고 좀비처럼 살아있는것 마냥..)

#### Memoization

- 우리는 이런 단순 분할 정복의 문제를 메모이제이션을 통해 해결할 수 있다.
- 이미 계산한 결과는 배열에 저장함으로써 나중에 동일 계산을 해야할 때는 저장된 값을 단순하게 반환만 할 수 있게 한다면 그 이전값을 반복해서 구해야하는 번거로움이 사라진다.
  (요즘 브라우저 최적화에 대한 생각을하며 Memoization에 대한 흥미가 조금 있는데 알고리즘에서도 만나서 반갑..)

# 그래서 풀이는..?

- 모든 풀이는 앞선 로직을 기반으로 한다. 거기서 최소한으로 줄일 수 있는 부분들을 줄여나가는 로직이 많다.

```
1. 개인적으로 가장 이해가 잘 되었던 코드..

var climbStairs = function(n) {
  1) var dp = [];
  2) dp[0] = 1;
  dp[1] = 1;


 3) for (let i = 2; i <= n; i += 1) {
 4)   dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
};
```

1. 먼저 값을 담을 dp 변수를 생성한다. 이는 메모이제이션을 이용하기 위함
2. 피보나치 수열의 원리에 의해 첫항과 둘째 항은 1로 설정
3. 반복문을 돌면서 이때 이미 둘째 항까지는 구해졌기에 셋째 항부터 시작할 수 있도록 i의 값을 2로 초기화하고 인자인 n까지의 값을 구해준다.(2인 이유는 세번째 인덱스 값이기에)
4. 구하고자 하는 항의 값 = 그 직전의 항의 값 + 그 직직전의 항의 값을 더한다는 수열의 원리에 의해 오른쪽의 이전 값들을 더해주고 그걸 저장해서 필요한 값들만 memoization해준다.

```
2. 이해하고 나서 보면 가장 짧게 나타낸거 같은 코드

var climbStairs = function(n) {
    a = b = 1
    while (n--)
        a = (b += a) - a
    return a
};
```

- 앞선 풀이와 차이점은 뒤에서 부터 순차적으로 계산해서 n이 1까지 계산을 해준다.
- 여기서 새로 알게되었던 점은 `while(n--)`이 뭐지 하게 엥? 했는데 조건문이 틀리기 전까지 반복하는 while문의 특성을 이용하여 n이 하나씩 마이너스 되며 0이 되기 전까지 실행되는,, 그런 구조.. 와우
- 2의 식은 짧지만 앞선 식과 시간 차이가 났는데 나의 추측으로는 1의 경우는 첫째 항과 둘째 항을 고정 값으로 두고 셋째 항부터 계산해나가는 식이라면,
- 2의 경우는 이미 첫째항과 둘째 항을 구했지만 n이 0이 되기 전까지 반복문이 돌아가며 첫째와 둘째를 한번 더 실행하게 되기 때문에 시간이 조금 더 걸린것으로 보인다. 고작 16ms 차이인데 leetcode 분석을 보면 시간 효율성이 일등과 꼴등 수준임... 아마 볼륨이 더 커지면 더 차이가 벌어지기 때문으로 추측...

### 살짝 후기

- 매번 잘 못풀어서 이렇게 알고리즘을 풀어가는게 맞나? 하던 요즘이었다.
- 하지만 진심으로 원리를 생각해내는 과정이 너무 즐거웠다. 비록 살짝 다른 접근이었지만, 어떤 패턴을 발견하고 그걸 어떻게 표현하면 좋을지 틀려도 고민하는 시간이 좋고 뿌듯하다.
- 도저히 내머리로는 안되겠다 싶어 답을 보는데 처음에 보고 너무 간단한데 또 이해를 하지 못하는 내 자신이 살짝 원망스러웠으나, 꼬리에 꼬리를 타고 이어지는 개념들과 최근에 공부하고 있는 메모이제이션이 나오니 아, 이래서 알고리즘을 푸는구나 싶었다.
- 오랜만에 본 수학적인 지식이 너무 재밌고 내가 알고있는 개념과 연관하여 재밌고 아직은 알아도 잘 이용할 수 있을지 모르겠지만, 언젠가 기반이 되어 실제 웹을 만들 때 이용하면 좋겠다는 생각이 들어 개인적으로 너무 뿌듯했다..
- 화이팅이다 화이팅..! 👐
