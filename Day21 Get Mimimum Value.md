오늘 LeetCode의 Binary Tree Inorder Traversal를 풀려고 시도하다가.... 또 자료구조의 늪에서 정신을 차리지 못하고 좌절감에 빠지게 되었다..
이대로는 내 자존감에 좋지 않을것 같아,, 뚜얀님이 공유해주신 인프런 알고리즘 문제의 초초급 단계를 풀며 힐링했는데,, (사실 뭔가 조금 자존심 상하긴 하는데,, 어쨌든..)
요즘 나의 고민은 정말 이런식으로 알고리즘을 풀어도 되는걸까 하는거다,, 너무 모르는거 같고 나아지는건가 싶어서 ㅠㅠ repl을 다시풀어야하나 프로그래머스는 너무 어려운데 leetcode도 어려운데 막 이런 생각 중,,, 푸는건 재밌는데 도전적이면서도 내가 풀수있는 수준을 찾는건 무척 어렵다..

# 문제

- 100이하의 자연수 A,B,C를 입력받아 세 수 중 가장 작은 값을 출력하는 프로그램 작성하기(단, 정렬을 사용해서는 안됨)

# 풀이

1. 기본적으로 생각한 풀이

```
function solution(a,b,c){
  let answer = 0;
  if(a<=b && a<=c){
    answer = a
  } else if(b<=a && b<=c){
    answer = b
  } else {
    answer = c
  }
    return answer
}
```

- 분명 LeetCode라면 테스트케이스를 엄청 빵빵 넣어서 틀릴 수도 있다. 막,, a,b,c가 모두 같은 경우 이런식으로,,
- 제일 기초적으로 생각할 수 있던건 각각의 수를 비교한 경우에 조건문을 만들어 주는것이었다.

2. Math.min을 활용한 풀이

```
function solution(a,b,c){
  const nums = []
  nums.push(a,b,c)
  return Math.min(...nums)
}

```

- 흠, 정렬을 사용하지 말랬는데 이 메소드는 정렬보다 더 간단히 끝나는거 같긴한데,, 사실 Math메소드도 배열에 쓰는 줄 알아서 저렇게 만들었는데 그냥 원괄호 안에 비교하려고 하는 값들만 넣어줘도 됨.. 막 `Math.min(a,b,c)`하면 한 줄에 다 끝남,,,, 하하
- 배열이라고 해도 저렇게 안하고 `nums=[a,b,c]`라고 해줄 수도 있음..
